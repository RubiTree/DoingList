{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar TransformOperationExecutor_1 = require(\"../TransformOperationExecutor\");\n/**\n * Storage all library metadata.\n */\n\n\nvar MetadataStorage =\n/** @class */\nfunction () {\n  function MetadataStorage() {\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n    this._typeMetadatas = new Map();\n    this._transformMetadatas = new Map();\n    this._exposeMetadatas = new Map();\n    this._excludeMetadatas = new Map();\n    this._ancestorsMap = new Map();\n  } // -------------------------------------------------------------------------\n  // Adder Methods\n  // -------------------------------------------------------------------------\n\n\n  MetadataStorage.prototype.addTypeMetadata = function (metadata) {\n    if (!this._typeMetadatas.has(metadata.target)) {\n      this._typeMetadatas.set(metadata.target, new Map());\n    }\n\n    this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  };\n\n  MetadataStorage.prototype.addTransformMetadata = function (metadata) {\n    if (!this._transformMetadatas.has(metadata.target)) {\n      this._transformMetadatas.set(metadata.target, new Map());\n    }\n\n    if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n      this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n    }\n\n    this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n  };\n\n  MetadataStorage.prototype.addExposeMetadata = function (metadata) {\n    if (!this._exposeMetadatas.has(metadata.target)) {\n      this._exposeMetadatas.set(metadata.target, new Map());\n    }\n\n    this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  };\n\n  MetadataStorage.prototype.addExcludeMetadata = function (metadata) {\n    if (!this._excludeMetadatas.has(metadata.target)) {\n      this._excludeMetadatas.set(metadata.target, new Map());\n    }\n\n    this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n  }; // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  MetadataStorage.prototype.findTransformMetadatas = function (target, propertyName, transformationType) {\n    return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(function (metadata) {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_CLASS || transformationType === TransformOperationExecutor_1.TransformationType.PLAIN_TO_CLASS;\n      }\n\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_PLAIN;\n      }\n\n      return true;\n    });\n  };\n\n  MetadataStorage.prototype.findExcludeMetadata = function (target, propertyName) {\n    return this.findMetadata(this._excludeMetadatas, target, propertyName);\n  };\n\n  MetadataStorage.prototype.findExposeMetadata = function (target, propertyName) {\n    return this.findMetadata(this._exposeMetadatas, target, propertyName);\n  };\n\n  MetadataStorage.prototype.findExposeMetadataByCustomName = function (target, name) {\n    return this.getExposedMetadatas(target).find(function (metadata) {\n      return metadata.options && metadata.options.name === name;\n    });\n  };\n\n  MetadataStorage.prototype.findTypeMetadata = function (target, propertyName) {\n    return this.findMetadata(this._typeMetadatas, target, propertyName);\n  };\n\n  MetadataStorage.prototype.getStrategy = function (target) {\n    var excludeMap = this._excludeMetadatas.get(target);\n\n    var exclude = excludeMap && excludeMap.get(undefined);\n\n    var exposeMap = this._exposeMetadatas.get(target);\n\n    var expose = exposeMap && exposeMap.get(undefined);\n    if (exclude && expose || !exclude && !expose) return \"none\";\n    return exclude ? \"excludeAll\" : \"exposeAll\";\n  };\n\n  MetadataStorage.prototype.getExposedMetadatas = function (target) {\n    return this.getMetadata(this._exposeMetadatas, target);\n  };\n\n  MetadataStorage.prototype.getExcludedMetadatas = function (target) {\n    return this.getMetadata(this._excludeMetadatas, target);\n  };\n\n  MetadataStorage.prototype.getExposedProperties = function (target, transformationType) {\n    return this.getExposedMetadatas(target).filter(function (metadata) {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_CLASS || transformationType === TransformOperationExecutor_1.TransformationType.PLAIN_TO_CLASS;\n      }\n\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_PLAIN;\n      }\n\n      return true;\n    }).map(function (metadata) {\n      return metadata.propertyName;\n    });\n  };\n\n  MetadataStorage.prototype.getExcludedProperties = function (target, transformationType) {\n    return this.getExcludedMetadatas(target).filter(function (metadata) {\n      if (!metadata.options) return true;\n      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;\n\n      if (metadata.options.toClassOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_CLASS || transformationType === TransformOperationExecutor_1.TransformationType.PLAIN_TO_CLASS;\n      }\n\n      if (metadata.options.toPlainOnly === true) {\n        return transformationType === TransformOperationExecutor_1.TransformationType.CLASS_TO_PLAIN;\n      }\n\n      return true;\n    }).map(function (metadata) {\n      return metadata.propertyName;\n    });\n  };\n\n  MetadataStorage.prototype.clear = function () {\n    this._typeMetadatas.clear();\n\n    this._exposeMetadatas.clear();\n\n    this._excludeMetadatas.clear();\n\n    this._ancestorsMap.clear();\n  }; // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n\n  MetadataStorage.prototype.getMetadata = function (metadatas, target) {\n    var metadataFromTargetMap = metadatas.get(target);\n    var metadataFromTarget;\n\n    if (metadataFromTargetMap) {\n      metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(function (meta) {\n        return meta.propertyName !== undefined;\n      });\n    }\n\n    var metadataFromAncestors = [];\n\n    for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n      var ancestor = _a[_i];\n      var ancestorMetadataMap = metadatas.get(ancestor);\n\n      if (ancestorMetadataMap) {\n        var metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(function (meta) {\n          return meta.propertyName !== undefined;\n        });\n        metadataFromAncestors.push.apply(metadataFromAncestors, metadataFromAncestor);\n      }\n    }\n\n    return metadataFromAncestors.concat(metadataFromTarget || []);\n  };\n\n  MetadataStorage.prototype.findMetadata = function (metadatas, target, propertyName) {\n    var metadataFromTargetMap = metadatas.get(target);\n\n    if (metadataFromTargetMap) {\n      var metadataFromTarget = metadataFromTargetMap.get(propertyName);\n\n      if (metadataFromTarget) {\n        return metadataFromTarget;\n      }\n    }\n\n    for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n      var ancestor = _a[_i];\n      var ancestorMetadataMap = metadatas.get(ancestor);\n\n      if (ancestorMetadataMap) {\n        var ancestorResult = ancestorMetadataMap.get(propertyName);\n\n        if (ancestorResult) {\n          return ancestorResult;\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  MetadataStorage.prototype.findMetadatas = function (metadatas, target, propertyName) {\n    var metadataFromTargetMap = metadatas.get(target);\n    var metadataFromTarget;\n\n    if (metadataFromTargetMap) {\n      metadataFromTarget = metadataFromTargetMap.get(propertyName);\n    }\n\n    var metadataFromAncestorsTarget = [];\n\n    for (var _i = 0, _a = this.getAncestors(target); _i < _a.length; _i++) {\n      var ancestor = _a[_i];\n      var ancestorMetadataMap = metadatas.get(ancestor);\n\n      if (ancestorMetadataMap) {\n        if (ancestorMetadataMap.has(propertyName)) {\n          metadataFromAncestorsTarget.push.apply(metadataFromAncestorsTarget, ancestorMetadataMap.get(propertyName));\n        }\n      }\n    }\n\n    return metadataFromAncestorsTarget.reverse().concat((metadataFromTarget || []).reverse());\n  };\n\n  MetadataStorage.prototype.getAncestors = function (target) {\n    if (!target) return [];\n\n    if (!this._ancestorsMap.has(target)) {\n      var ancestors = [];\n\n      for (var baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== \"undefined\"; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {\n        ancestors.push(baseClass);\n      }\n\n      this._ancestorsMap.set(target, ancestors);\n    }\n\n    return this._ancestorsMap.get(target);\n  };\n\n  return MetadataStorage;\n}();\n\nexports.MetadataStorage = MetadataStorage;","map":{"version":3,"sources":["../../src/metadata/MetadataStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import {TypeMetadata} from \"./TypeMetadata\";\nimport {ExposeMetadata} from \"./ExposeMetadata\";\nimport {ExcludeMetadata} from \"./ExcludeMetadata\";\nimport {TransformationType} from \"../TransformOperationExecutor\";\nimport {TransformMetadata} from \"./TransformMetadata\";\n\n/**\n * Storage all library metadata.\n */\nexport class MetadataStorage {\n\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    private _typeMetadatas = new Map<Function, Map<string, TypeMetadata>>();\n    private _transformMetadatas = new Map<Function, Map<string, TransformMetadata[]>>();\n    private _exposeMetadatas = new Map<Function, Map<string, ExposeMetadata>>();\n    private _excludeMetadatas = new Map<Function, Map<string, ExcludeMetadata>>();\n    private _ancestorsMap = new Map<Function, Function[]>();\n\n    // -------------------------------------------------------------------------\n    // Adder Methods\n    // -------------------------------------------------------------------------\n\n    addTypeMetadata(metadata: TypeMetadata) {\n        if (!this._typeMetadatas.has(metadata.target)) {\n            this._typeMetadatas.set(metadata.target, new Map<string, TypeMetadata>());\n    }\n        this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    }\n\n    addTransformMetadata(metadata: TransformMetadata) {\n        if (!this._transformMetadatas.has(metadata.target)) {\n            this._transformMetadatas.set(metadata.target, new Map<string, TransformMetadata[]>());\n    }\n        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {\n            this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);\n        }\n        this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);\n    }\n\n    addExposeMetadata(metadata: ExposeMetadata) {\n        if (!this._exposeMetadatas.has(metadata.target)) {\n            this._exposeMetadatas.set(metadata.target, new Map<string, ExposeMetadata>());\n    }\n        this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    }\n\n    addExcludeMetadata(metadata: ExcludeMetadata) {\n        if (!this._excludeMetadatas.has(metadata.target)) {\n            this._excludeMetadatas.set(metadata.target, new Map<string, ExcludeMetadata>());\n    }\n        this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    findTransformMetadatas(target: Function, propertyName: string, transformationType: TransformationType): TransformMetadata[] {\n        return this.findMetadatas(this._transformMetadatas, target, propertyName)\n            .filter(metadata => {\n                if (!metadata.options)\n                    return true;\n                if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                    return true;\n\n                if (metadata.options.toClassOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;\n                }\n                if (metadata.options.toPlainOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_PLAIN;\n                }\n\n                return true;\n            });\n    }\n\n    findExcludeMetadata(target: Function, propertyName: string): ExcludeMetadata {\n        return this.findMetadata(this._excludeMetadatas, target, propertyName);\n    }\n\n    findExposeMetadata(target: Function, propertyName: string): ExposeMetadata {\n        return this.findMetadata(this._exposeMetadatas, target, propertyName);\n    }\n\n    findExposeMetadataByCustomName(target: Function, name: string): ExposeMetadata {\n        return this.getExposedMetadatas(target).find(metadata => {\n            return metadata.options && metadata.options.name === name;\n        });\n    }\n\n    findTypeMetadata(target: Function, propertyName: string) {\n        return this.findMetadata(this._typeMetadatas, target, propertyName);\n    }\n\n    getStrategy(target: Function): \"excludeAll\"|\"exposeAll\"|\"none\" {\n        const excludeMap = this._excludeMetadatas.get(target);\n        const exclude = excludeMap && excludeMap.get(undefined);\n        const exposeMap = this._exposeMetadatas.get(target);\n        const expose = exposeMap && exposeMap.get(undefined);\n        if ((exclude && expose) || (!exclude && !expose)) return \"none\";\n        return exclude ? \"excludeAll\" : \"exposeAll\";\n    }\n\n    getExposedMetadatas(target: Function): ExposeMetadata[] {\n        return this.getMetadata(this._exposeMetadatas, target);\n    }\n\n    getExcludedMetadatas(target: Function): ExcludeMetadata[] {\n        return this.getMetadata(this._excludeMetadatas, target);\n    }\n\n    getExposedProperties(target: Function, transformationType: TransformationType): string[] {\n        return this.getExposedMetadatas(target)\n            .filter(metadata => {\n                if (!metadata.options)\n                    return true;\n                if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                    return true;\n\n                if (metadata.options.toClassOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;\n                }\n                if (metadata.options.toPlainOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_PLAIN;\n                }\n\n                return true;\n            })\n            .map(metadata => metadata.propertyName);\n    }\n\n    getExcludedProperties(target: Function, transformationType: TransformationType): string[] {\n        return this.getExcludedMetadatas(target)\n            .filter(metadata => {\n                if (!metadata.options)\n                    return true;\n                if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)\n                    return true;\n\n                if (metadata.options.toClassOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;\n                }\n                if (metadata.options.toPlainOnly === true) {\n                    return transformationType === TransformationType.CLASS_TO_PLAIN;\n                }\n\n                return true;\n            })\n            .map(metadata => metadata.propertyName);\n    }\n\n    clear() {\n        this._typeMetadatas.clear();\n        this._exposeMetadatas.clear();\n        this._excludeMetadatas.clear();\n        this._ancestorsMap.clear();\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private getMetadata<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<String, T>>, target: Function): T[] {\n        const metadataFromTargetMap = metadatas.get(target);\n        let metadataFromTarget: T[];\n        if (metadataFromTargetMap) {\n            metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);\n        }\n        let metadataFromAncestors: T[] = [];\n        for (const ancestor of this.getAncestors(target)) {\n            const ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(meta => meta.propertyName !== undefined);\n                metadataFromAncestors.push(...metadataFromAncestor);\n            }\n        }        \n        return metadataFromAncestors.concat(metadataFromTarget || []);\n    }\n\n    private findMetadata<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<string, T>>, target: Function, propertyName: string): T {\n        const metadataFromTargetMap = metadatas.get(target);\n        if (metadataFromTargetMap) {\n            const metadataFromTarget = metadataFromTargetMap.get(propertyName);  \n            if (metadataFromTarget) {\n                return metadataFromTarget;\n            }\n        }\n        for (const ancestor of this.getAncestors(target)) {\n            const ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                const ancestorResult = ancestorMetadataMap.get(propertyName);\n                if (ancestorResult) {\n                  return ancestorResult;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    private findMetadatas<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<string, T[]>>, target: Function, propertyName: string): T[] {\n        const metadataFromTargetMap = metadatas.get(target);\n        let metadataFromTarget: T[];\n        if (metadataFromTargetMap) {\n            metadataFromTarget = metadataFromTargetMap.get(propertyName);    \n        }\n        let metadataFromAncestorsTarget: T[] = [];\n        for (const ancestor of this.getAncestors(target)) {\n            const ancestorMetadataMap = metadatas.get(ancestor);\n            if (ancestorMetadataMap) {\n                if (ancestorMetadataMap.has(propertyName)) {\n                  metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));\n                }\n            }\n        }\n        return (metadataFromAncestorsTarget).reverse().concat((metadataFromTarget || []).reverse());\n    }\n\n    private getAncestors(target: Function): Function[] {\n        if (!target) return [];\n        if (!this._ancestorsMap.has(target)) {\n            let ancestors: Function[] = [];\n            for (let baseClass = Object.getPrototypeOf(target.prototype.constructor);\n                 typeof baseClass.prototype !== \"undefined\";\n                 baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {\n                ancestors.push(baseClass);\n            }\n            this._ancestorsMap.set(target, ancestors);\n        }\n        return this._ancestorsMap.get(target);\n    }\n}\n"],"sourceRoot":".."},"metadata":{},"sourceType":"script"}