{"ast":null,"code":"import Format from '../utils/Format';\nimport Utils from '../utils/Utils';\n\nclass TaskInfoFormat {\n  static getDoingStatusTips(task) {\n    if (task.isDoing()) {\n      return \"æ–½å·¥ä¸­â›‘ \";\n    } else {\n      return \"\";\n    }\n  }\n\n  static getConsumed(task) {\n    let time = Format.formatDuration2(task.getAllDuration());\n\n    if (Utils.isStringEmpty(time)) {\n      return \"\";\n    }\n\n    return `è¿›è¡Œ${time}(${task.doingDurs.length}æ¬¡) `;\n  }\n\n  static getDeadline(task) {\n    let deadline = task.getActualDeadline();\n\n    if (deadline <= 0) {\n      return \"\";\n    }\n\n    const leftTime = deadline - Utils.getTimestamp();\n\n    if (leftTime <= 1000) {\n      return `å·²è¶…æœŸðŸ˜± `;\n    }\n\n    let time = Format.formatDuration2(leftTime);\n    return `å‰©ä½™${time} `;\n  }\n\n  static getPendingStatus(task) {\n    let deadline = task.pendingDeadline;\n\n    if (deadline <= 0) {\n      return \"\";\n    }\n\n    const leftTime = deadline - Utils.getTimestamp();\n\n    if (leftTime <= 1000) {\n      return `Pendå·²è¶…æœŸðŸ˜± `;\n    }\n\n    let time = Format.formatDuration2(leftTime);\n    return `Pendå‰©ä½™${time} `;\n  }\n\n  static getConsumeExpected(task) {\n    if (task.getActualExpectConsume() <= 0) {\n      return \"\";\n    }\n\n    let left = task.getLeftExpectConsumeTime();\n\n    if (left <= 0) {\n      return `è¶…å‡º${Format.formatDuration2(-left)}`;\n    } else {\n      return `è¿˜éœ€${Format.formatDuration2(left)}`;\n    }\n  }\n\n}\n\nexport default TaskInfoFormat;","map":{"version":3,"sources":["/Users/bear/Develop/vscode/self/study/study1/React/DoingList/doinglist2/src/utils/TaskInfoFormat.ts"],"names":["Format","Utils","TaskInfoFormat","getDoingStatusTips","task","isDoing","getConsumed","time","formatDuration2","getAllDuration","isStringEmpty","doingDurs","length","getDeadline","deadline","getActualDeadline","leftTime","getTimestamp","getPendingStatus","pendingDeadline","getConsumeExpected","getActualExpectConsume","left","getLeftExpectConsumeTime"],"mappings":"AACA,OAAOA,MAAP,MAAmB,iBAAnB;AACA,OAAOC,KAAP,MAAkB,gBAAlB;;AAEA,MAAMC,cAAN,CAAqB;AAEjB,SAAcC,kBAAd,CAAiCC,IAAjC,EAAqD;AACjD,QAAIA,IAAI,CAACC,OAAL,EAAJ,EAAoB;AAClB,aAAO,OAAP;AACD,KAFD,MAEO;AACL,aAAO,EAAP;AACD;AACF;;AAED,SAAcC,WAAd,CAA0BF,IAA1B,EAA8C;AAC5C,QAAIG,IAAI,GAAGP,MAAM,CAACQ,eAAP,CAAuBJ,IAAI,CAACK,cAAL,EAAvB,CAAX;;AACA,QAAIR,KAAK,CAACS,aAAN,CAAoBH,IAApB,CAAJ,EAA+B;AAC7B,aAAO,EAAP;AACD;;AACD,WAAQ,KAAIA,IAAK,IAAGH,IAAI,CAACO,SAAL,CAAeC,MAAO,KAA1C;AACD;;AAED,SAAcC,WAAd,CAA0BT,IAA1B,EAA8C;AAC5C,QAAIU,QAAQ,GAAGV,IAAI,CAACW,iBAAL,EAAf;;AACA,QAAID,QAAQ,IAAI,CAAhB,EAAmB;AACjB,aAAO,EAAP;AACD;;AACD,UAAME,QAAQ,GAAGF,QAAQ,GAAGb,KAAK,CAACgB,YAAN,EAA5B;;AACA,QAAID,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAQ,QAAR;AACD;;AACD,QAAIT,IAAI,GAAGP,MAAM,CAACQ,eAAP,CAAuBQ,QAAvB,CAAX;AACA,WAAQ,KAAIT,IAAK,GAAjB;AACD;;AAED,SAAcW,gBAAd,CAA+Bd,IAA/B,EAAmD;AACjD,QAAIU,QAAQ,GAAGV,IAAI,CAACe,eAApB;;AACA,QAAIL,QAAQ,IAAI,CAAhB,EAAmB;AACjB,aAAO,EAAP;AACD;;AACD,UAAME,QAAQ,GAAGF,QAAQ,GAAGb,KAAK,CAACgB,YAAN,EAA5B;;AACA,QAAID,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAQ,YAAR;AACD;;AACD,QAAIT,IAAI,GAAGP,MAAM,CAACQ,eAAP,CAAuBQ,QAAvB,CAAX;AACA,WAAQ,SAAQT,IAAK,GAArB;AACD;;AAED,SAAca,kBAAd,CAAiChB,IAAjC,EAAqD;AACnD,QAAIA,IAAI,CAACiB,sBAAL,MAAiC,CAArC,EAAwC;AACtC,aAAO,EAAP;AACD;;AAED,QAAIC,IAAI,GAAGlB,IAAI,CAACmB,wBAAL,EAAX;;AACA,QAAID,IAAI,IAAI,CAAZ,EAAe;AACb,aAAQ,KAAItB,MAAM,CAACQ,eAAP,CAAuB,CAACc,IAAxB,CAA8B,EAA1C;AACD,KAFD,MAEO;AACL,aAAQ,KAAItB,MAAM,CAACQ,eAAP,CAAuBc,IAAvB,CAA6B,EAAzC;AACD;AACF;;AAvDc;;AA0DrB,eAAepB,cAAf","sourcesContent":["import { Task } from '../model/model'\nimport Format from '../utils/Format'\nimport Utils from '../utils/Utils'\n\nclass TaskInfoFormat {\n\n    public static getDoingStatusTips(task: Task): string {\n        if (task.isDoing()) {\n          return \"æ–½å·¥ä¸­â›‘ \"\n        } else {\n          return \"\"\n        }\n      }\n    \n      public static getConsumed(task: Task): string {\n        let time = Format.formatDuration2(task.getAllDuration());\n        if (Utils.isStringEmpty(time)) {\n          return \"\"\n        }\n        return `è¿›è¡Œ${time}(${task.doingDurs.length}æ¬¡) `\n      }\n    \n      public static getDeadline(task: Task): string {\n        let deadline = task.getActualDeadline()\n        if (deadline <= 0) {\n          return \"\"\n        }\n        const leftTime = deadline - Utils.getTimestamp();\n        if (leftTime <= 1000) {\n          return `å·²è¶…æœŸðŸ˜± `\n        }\n        let time = Format.formatDuration2(leftTime);\n        return `å‰©ä½™${time} `\n      }\n\n      public static getPendingStatus(task: Task): string {\n        let deadline = task.pendingDeadline\n        if (deadline <= 0) {\n          return \"\"\n        }\n        const leftTime = deadline - Utils.getTimestamp();\n        if (leftTime <= 1000) {\n          return `Pendå·²è¶…æœŸðŸ˜± `\n        }\n        let time = Format.formatDuration2(leftTime);\n        return `Pendå‰©ä½™${time} `\n      }\n    \n      public static getConsumeExpected(task: Task): string {\n        if (task.getActualExpectConsume() <= 0) {\n          return \"\"\n        }\n    \n        let left = task.getLeftExpectConsumeTime()\n        if (left <= 0) {\n          return `è¶…å‡º${Format.formatDuration2(-left)}`\n        } else {\n          return `è¿˜éœ€${Format.formatDuration2(left)}`\n        }\n      }\n}\n\nexport default TaskInfoFormat"]},"metadata":{},"sourceType":"module"}