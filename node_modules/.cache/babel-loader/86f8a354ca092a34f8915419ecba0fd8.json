{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar storage_1 = require(\"./storage\");\n\nvar TransformationType;\n\n(function (TransformationType) {\n  TransformationType[TransformationType[\"PLAIN_TO_CLASS\"] = 0] = \"PLAIN_TO_CLASS\";\n  TransformationType[TransformationType[\"CLASS_TO_PLAIN\"] = 1] = \"CLASS_TO_PLAIN\";\n  TransformationType[TransformationType[\"CLASS_TO_CLASS\"] = 2] = \"CLASS_TO_CLASS\";\n})(TransformationType = exports.TransformationType || (exports.TransformationType = {}));\n\nvar TransformOperationExecutor =\n/** @class */\nfunction () {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  function TransformOperationExecutor(transformationType, options) {\n    this.transformationType = transformationType;\n    this.options = options; // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    this.recursionStack = new Set();\n  } // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n\n  TransformOperationExecutor.prototype.transform = function (source, value, targetType, arrayType, isMap, level) {\n    var _this = this;\n\n    if (level === void 0) {\n      level = 0;\n    }\n\n    if (Array.isArray(value) || value instanceof Set) {\n      var newValue_1 = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];\n      value.forEach(function (subValue, index) {\n        var subSource = source ? source[index] : undefined;\n\n        if (!_this.options.enableCircularCheck || !_this.isCircular(subValue)) {\n          var realTargetType = void 0;\n\n          if (typeof targetType !== \"function\" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {\n            if (_this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n              realTargetType = targetType.options.discriminator.subTypes.find(function (subType) {\n                return subType.name === subValue[targetType.options.discriminator.property];\n              });\n              var options = {\n                newObject: newValue_1,\n                object: subValue,\n                property: undefined\n              };\n              var newType = targetType.typeFunction(options);\n              realTargetType === undefined ? realTargetType = newType : realTargetType = realTargetType.value;\n              if (!targetType.options.keepDiscriminatorProperty) delete subValue[targetType.options.discriminator.property];\n            }\n\n            if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\n              realTargetType = subValue.constructor;\n            }\n\n            if (_this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n              subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(function (subType) {\n                return subType.value === subValue.constructor;\n              }).name;\n            }\n          } else {\n            realTargetType = targetType;\n          }\n\n          var value_1 = _this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);\n\n          if (newValue_1 instanceof Set) {\n            newValue_1.add(value_1);\n          } else {\n            newValue_1.push(value_1);\n          }\n        } else if (_this.transformationType === TransformationType.CLASS_TO_CLASS) {\n          if (newValue_1 instanceof Set) {\n            newValue_1.add(subValue);\n          } else {\n            newValue_1.push(subValue);\n          }\n        }\n      });\n      return newValue_1;\n    } else if (targetType === String && !isMap) {\n      if (value === null || value === undefined) return value;\n      return String(value);\n    } else if (targetType === Number && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Number(value);\n    } else if (targetType === Boolean && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Boolean(value);\n    } else if ((targetType === Date || value instanceof Date) && !isMap) {\n      if (value instanceof Date) {\n        return new Date(value.valueOf());\n      }\n\n      if (value === null || value === undefined) return value;\n      return new Date(value);\n    } else if (testForBuffer() && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n      if (value === null || value === undefined) return value;\n      return Buffer.from(value);\n    } else if (typeof value === \"object\" && value !== null) {\n      // try to guess the type\n      if (!targetType && value.constructor !== Object\n      /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/\n      ) targetType = value.constructor;\n      if (!targetType && source) targetType = source.constructor;\n\n      if (this.options.enableCircularCheck) {\n        // add transformed type to prevent circular references\n        this.recursionStack.add(value);\n      }\n\n      var keys = this.getKeys(targetType, value);\n      var newValue = source ? source : {};\n\n      if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {\n        if (isMap) {\n          newValue = new Map();\n        } else if (targetType) {\n          newValue = new targetType();\n        } else {\n          newValue = {};\n        }\n      }\n\n      var _loop_1 = function _loop_1(key) {\n        var valueKey = key,\n            newValueKey = key,\n            propertyName = key;\n\n        if (!this_1.options.ignoreDecorators && targetType) {\n          if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key);\n\n            if (exposeMetadata) {\n              propertyName = exposeMetadata.propertyName;\n              newValueKey = exposeMetadata.propertyName;\n            }\n          } else if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN || this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n            var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(targetType, key);\n\n            if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n              newValueKey = exposeMetadata.options.name;\n            }\n          }\n        } // get a subvalue\n\n\n        var subValue = undefined;\n\n        if (value instanceof Map) {\n          subValue = value.get(valueKey);\n        } else if (value[valueKey] instanceof Function) {\n          subValue = value[valueKey]();\n        } else {\n          subValue = value[valueKey];\n        } // determine a type\n\n\n        var type = undefined,\n            isSubValueMap = subValue instanceof Map;\n\n        if (targetType && isMap) {\n          type = targetType;\n        } else if (targetType) {\n          var metadata_1 = storage_1.defaultMetadataStorage.findTypeMetadata(targetType, propertyName);\n\n          if (metadata_1) {\n            var options = {\n              newObject: newValue,\n              object: value,\n              property: propertyName\n            };\n            var newType = metadata_1.typeFunction ? metadata_1.typeFunction(options) : metadata_1.reflectedType;\n\n            if (metadata_1.options && metadata_1.options.discriminator && metadata_1.options.discriminator.property && metadata_1.options.discriminator.subTypes) {\n              if (!(value[valueKey] instanceof Array)) {\n                if (this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                  type = metadata_1.options.discriminator.subTypes.find(function (subType) {\n                    if (subValue && metadata_1.options.discriminator.property in subValue) {\n                      return subType.name === subValue[metadata_1.options.discriminator.property];\n                    }\n                  });\n                  type === undefined ? type = newType : type = type.value;\n\n                  if (!metadata_1.options.keepDiscriminatorProperty) {\n                    if (subValue && metadata_1.options.discriminator.property in subValue) {\n                      delete subValue[metadata_1.options.discriminator.property];\n                    }\n                  }\n                }\n\n                if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n                  type = subValue.constructor;\n                }\n\n                if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                  subValue[metadata_1.options.discriminator.property] = metadata_1.options.discriminator.subTypes.find(function (subType) {\n                    return subType.value === subValue.constructor;\n                  }).name;\n                }\n              } else {\n                type = metadata_1;\n              }\n            } else {\n              type = newType;\n            }\n\n            isSubValueMap = isSubValueMap || metadata_1.reflectedType === Map;\n          } else if (this_1.options.targetMaps) {\n            // try to find a type in target maps\n            this_1.options.targetMaps.filter(function (map) {\n              return map.target === targetType && !!map.properties[propertyName];\n            }).forEach(function (map) {\n              return type = map.properties[propertyName];\n            });\n          } else if (this_1.options.enableImplicitConversion && this_1.transformationType === TransformationType.PLAIN_TO_CLASS) {\n            // if we have no registererd type via the @Type() decorator then we check if we have any\n            // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n            var reflectedType = Reflect.getMetadata(\"design:type\", targetType.prototype, propertyName);\n\n            if (reflectedType) {\n              type = reflectedType;\n            }\n          }\n        } // if value is an array try to get its custom array type\n\n\n        var arrayType_1 = Array.isArray(value[valueKey]) ? this_1.getReflectedType(targetType, propertyName) : undefined; // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n\n        var subSource = source ? source[valueKey] : undefined; // if its deserialization then type if required\n        // if we uncomment this types like string[] will not work\n        // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n        //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n        // if newValue is a source object that has method that match newKeyName then skip it\n\n        if (newValue.constructor.prototype) {\n          var descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n          if ((this_1.transformationType === TransformationType.PLAIN_TO_CLASS || this_1.transformationType === TransformationType.CLASS_TO_CLASS) && (descriptor && !descriptor.set || newValue[newValueKey] instanceof Function)) //  || TransformationType === TransformationType.CLASS_TO_CLASS\n            return \"continue\";\n        }\n\n        if (!this_1.options.enableCircularCheck || !this_1.isCircular(subValue)) {\n          var transformKey = this_1.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n          var finalValue = void 0;\n\n          if (this_1.transformationType === TransformationType.CLASS_TO_PLAIN) {\n            // Get original value\n            finalValue = value[transformKey]; // Apply custom transformation\n\n            finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType); // If nothing change, it means no custom transformation was applied, so use the subValue.\n\n            finalValue = value[transformKey] === finalValue ? subValue : finalValue; // Apply the default transformation\n\n            finalValue = this_1.transform(subSource, finalValue, type, arrayType_1, isSubValueMap, level + 1);\n          } else {\n            finalValue = this_1.transform(subSource, subValue, type, arrayType_1, isSubValueMap, level + 1);\n            finalValue = this_1.applyCustomTransformations(finalValue, targetType, transformKey, value, this_1.transformationType);\n          }\n\n          if (newValue instanceof Map) {\n            newValue.set(newValueKey, finalValue);\n          } else {\n            newValue[newValueKey] = finalValue;\n          }\n        } else if (this_1.transformationType === TransformationType.CLASS_TO_CLASS) {\n          var finalValue = subValue;\n          finalValue = this_1.applyCustomTransformations(finalValue, targetType, key, value, this_1.transformationType);\n\n          if (newValue instanceof Map) {\n            newValue.set(newValueKey, finalValue);\n          } else {\n            newValue[newValueKey] = finalValue;\n          }\n        }\n      };\n\n      var this_1 = this; // traverse over keys\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n\n        _loop_1(key);\n      }\n\n      if (this.options.enableCircularCheck) {\n        this.recursionStack.delete(value);\n      }\n\n      return newValue;\n    } else {\n      return value;\n    }\n  };\n\n  TransformOperationExecutor.prototype.applyCustomTransformations = function (value, target, key, obj, transformationType) {\n    var _this = this;\n\n    var metadatas = storage_1.defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType); // apply versioning options\n\n    if (this.options.version !== undefined) {\n      metadatas = metadatas.filter(function (metadata) {\n        if (!metadata.options) return true;\n        return _this.checkVersion(metadata.options.since, metadata.options.until);\n      });\n    } // apply grouping options\n\n\n    if (this.options.groups && this.options.groups.length) {\n      metadatas = metadatas.filter(function (metadata) {\n        if (!metadata.options) return true;\n        return _this.checkGroups(metadata.options.groups);\n      });\n    } else {\n      metadatas = metadatas.filter(function (metadata) {\n        return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n      });\n    }\n\n    metadatas.forEach(function (metadata) {\n      value = metadata.transformFn(value, obj, transformationType);\n    });\n    return value;\n  }; // preventing circular references\n\n\n  TransformOperationExecutor.prototype.isCircular = function (object) {\n    return this.recursionStack.has(object);\n  };\n\n  TransformOperationExecutor.prototype.getReflectedType = function (target, propertyName) {\n    if (!target) return undefined;\n    var meta = storage_1.defaultMetadataStorage.findTypeMetadata(target, propertyName);\n    return meta ? meta.reflectedType : undefined;\n  };\n\n  TransformOperationExecutor.prototype.getKeys = function (target, object) {\n    var _this = this; // determine exclusion strategy\n\n\n    var strategy = storage_1.defaultMetadataStorage.getStrategy(target);\n    if (strategy === \"none\") strategy = this.options.strategy || \"exposeAll\"; // exposeAll is default strategy\n    // get all keys that need to expose\n\n    var keys = [];\n\n    if (strategy === \"exposeAll\") {\n      if (object instanceof Map) {\n        keys = Array.from(object.keys());\n      } else {\n        keys = Object.keys(object);\n      }\n    }\n\n    if (!this.options.ignoreDecorators && target) {\n      // add all exposed to list of keys\n      var exposedProperties = storage_1.defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n\n      if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n        exposedProperties = exposedProperties.map(function (key) {\n          var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);\n\n          if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n            return exposeMetadata.options.name;\n          }\n\n          return key;\n        });\n      }\n\n      if (this.options.excludeExtraneousValues) {\n        keys = exposedProperties;\n      } else {\n        keys = keys.concat(exposedProperties);\n      } // exclude excluded properties\n\n\n      var excludedProperties_1 = storage_1.defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n\n      if (excludedProperties_1.length > 0) {\n        keys = keys.filter(function (key) {\n          return excludedProperties_1.indexOf(key) === -1;\n        });\n      } // apply versioning options\n\n\n      if (this.options.version !== undefined) {\n        keys = keys.filter(function (key) {\n          var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n          return _this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n        });\n      } // apply grouping options\n\n\n      if (this.options.groups && this.options.groups.length) {\n        keys = keys.filter(function (key) {\n          var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);\n          if (!exposeMetadata || !exposeMetadata.options) return true;\n          return _this.checkGroups(exposeMetadata.options.groups);\n        });\n      } else {\n        keys = keys.filter(function (key) {\n          var exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);\n          return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;\n        });\n      }\n    } // exclude prefixed properties\n\n\n    if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n      keys = keys.filter(function (key) {\n        return _this.options.excludePrefixes.every(function (prefix) {\n          return key.substr(0, prefix.length) !== prefix;\n        });\n      });\n    } // make sure we have unique keys\n\n\n    keys = keys.filter(function (key, index, self) {\n      return self.indexOf(key) === index;\n    });\n    return keys;\n  };\n\n  TransformOperationExecutor.prototype.checkVersion = function (since, until) {\n    var decision = true;\n    if (decision && since) decision = this.options.version >= since;\n    if (decision && until) decision = this.options.version < until;\n    return decision;\n  };\n\n  TransformOperationExecutor.prototype.checkGroups = function (groups) {\n    if (!groups) return true;\n    return this.options.groups.some(function (optionGroup) {\n      return groups.indexOf(optionGroup) !== -1;\n    });\n  };\n\n  return TransformOperationExecutor;\n}();\n\nexports.TransformOperationExecutor = TransformOperationExecutor;\n\nfunction instantiateArrayType(arrayType) {\n  var array = new arrayType();\n\n  if (!(array instanceof Set) && !(\"push\" in array)) {\n    return [];\n  }\n\n  return array;\n}\n\nfunction testForBuffer() {\n  try {\n    Buffer;\n    return true;\n  } catch (_a) {}\n\n  return false;\n}\n\nexports.testForBuffer = testForBuffer;","map":{"version":3,"sources":["../../src/TransformOperationExecutor.ts"],"names":[],"mappings":"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","sourcesContent":["import { ClassTransformOptions } from \"./ClassTransformOptions\";\nimport { defaultMetadataStorage } from \"./storage\";\nimport { TypeHelpOptions, TypeOptions } from \"./metadata/ExposeExcludeOptions\";\nimport { TypeMetadata } from \"./metadata/TypeMetadata\";\n\nexport enum TransformationType {\n    PLAIN_TO_CLASS,\n    CLASS_TO_PLAIN,\n    CLASS_TO_CLASS\n}\n\nexport class TransformOperationExecutor {\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private recursionStack = new Set<Object>();\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(private transformationType: TransformationType,\n        private options: ClassTransformOptions) {\n    }\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    transform(source: Object | Object[] | any,\n        value: Object | Object[] | any,\n        targetType: Function | TypeMetadata,\n        arrayType: Function,\n        isMap: boolean,\n        level: number = 0) {\n\n        if (Array.isArray(value) || value instanceof Set) {\n            const newValue = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];\n            (value as any[]).forEach((subValue, index) => {\n                const subSource = source ? source[index] : undefined;\n                if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n                    let realTargetType;\n                    if (typeof targetType !== \"function\" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {\n                        if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                            realTargetType = targetType.options.discriminator.subTypes.find((subType) => subType.name === subValue[(targetType as { options: TypeOptions }).options.discriminator.property]);\n                            const options: TypeHelpOptions = { newObject: newValue, object: subValue, property: undefined };\n                            const newType = targetType.typeFunction(options);\n                            realTargetType === undefined ? realTargetType = newType : realTargetType = realTargetType.value;\n                            if (!targetType.options.keepDiscriminatorProperty) delete subValue[targetType.options.discriminator.property];\n                        }\n                        if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                            realTargetType = subValue.constructor;\n                        }\n                        if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                            subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;\n                        }\n                    } else {\n                        realTargetType = targetType;\n                    }\n                    const value = this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);\n\n                    if (newValue instanceof Set) {\n                        newValue.add(value);\n                    } else {\n                        newValue.push(value);\n                    }\n                } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                    if (newValue instanceof Set) {\n                        newValue.add(subValue);\n                    } else {\n                        newValue.push(subValue);\n                    }\n                }\n            });\n            return newValue;\n        } else if (targetType === String && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return String(value);\n\n        } else if (targetType === Number && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Number(value);\n\n        } else if (targetType === Boolean && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Boolean(value);\n\n        } else if ((targetType === Date || value instanceof Date) && !isMap) {\n            if (value instanceof Date) {\n                return new Date(value.valueOf());\n            }\n            if (value === null || value === undefined)\n                return value;\n            return new Date(value);\n\n        } else if (testForBuffer() && (targetType === Buffer || value instanceof Buffer) && !isMap) {\n            if (value === null || value === undefined)\n                return value;\n            return Buffer.from(value);\n\n        } else if (typeof value === \"object\" && value !== null) {\n\n            // try to guess the type\n            if (!targetType && value.constructor !== Object/* && TransformationType === TransformationType.CLASS_TO_PLAIN*/) targetType = value.constructor;\n            if (!targetType && source) targetType = source.constructor;\n\n            if (this.options.enableCircularCheck) {\n                // add transformed type to prevent circular references\n                this.recursionStack.add(value);\n            }\n\n            const keys = this.getKeys((targetType as Function), value);\n            let newValue: any = source ? source : {};\n            if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {\n                if (isMap) {\n                    newValue = new Map();\n                } else if (targetType) {\n                    newValue = new (targetType as any)();\n                } else {\n                    newValue = {};\n                }\n            }\n\n            // traverse over keys\n            for (let key of keys) {\n\n                let valueKey = key, newValueKey = key, propertyName = key;\n                if (!this.options.ignoreDecorators && targetType) {\n                    if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                        const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName((targetType as Function), key);\n                        if (exposeMetadata) {\n                            propertyName = exposeMetadata.propertyName;\n                            newValueKey = exposeMetadata.propertyName;\n                        }\n\n                    } else if (this.transformationType === TransformationType.CLASS_TO_PLAIN || this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                        const exposeMetadata = defaultMetadataStorage.findExposeMetadata((targetType as Function), key);\n                        if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n                            newValueKey = exposeMetadata.options.name;\n                        }\n                    }\n                }\n\n                // get a subvalue\n                let subValue: any = undefined;\n                if (value instanceof Map) {\n                    subValue = value.get(valueKey);\n                } else if (value[valueKey] instanceof Function) {\n                    subValue = value[valueKey]();\n                } else {\n                    subValue = value[valueKey];\n                }\n\n                // determine a type\n                let type: any = undefined, isSubValueMap = subValue instanceof Map;\n                if (targetType && isMap) {\n                    type = targetType;\n\n                } else if (targetType) {\n\n                    const metadata = defaultMetadataStorage.findTypeMetadata((targetType as Function), propertyName);\n                    if (metadata) {\n                        const options: TypeHelpOptions = { newObject: newValue, object: value, property: propertyName };\n                        const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;\n                        if (metadata.options && metadata.options.discriminator && metadata.options.discriminator.property && metadata.options.discriminator.subTypes) {\n                            if (!(value[valueKey] instanceof Array)) {\n                                if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                                    type = metadata.options.discriminator.subTypes.find((subType) => {\n                                        if (subValue && metadata.options.discriminator.property in subValue) {\n                                            return subType.name === subValue[metadata.options.discriminator.property]\n                                        }\n                                    });\n                                    type === undefined ? type = newType : type = type.value;\n                                    if (!metadata.options.keepDiscriminatorProperty) {\n                                        if (subValue && metadata.options.discriminator.property in subValue) {\n                                            delete subValue[metadata.options.discriminator.property];\n                                        }\n                                    }\n                                }\n                                if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                                    type = subValue.constructor;\n                                }\n                                if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                                    subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;\n                                }\n                            } else {\n                                type = metadata;\n                            }\n                        } else {\n                            type = newType;\n                        }\n                        isSubValueMap = isSubValueMap || metadata.reflectedType === Map;\n                    } else if (this.options.targetMaps) { // try to find a type in target maps\n                        this.options.targetMaps\n                            .filter(map => map.target === targetType && !!map.properties[propertyName])\n                            .forEach(map => type = map.properties[propertyName]);\n                    } else if(this.options.enableImplicitConversion && this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                        // if we have no registererd type via the @Type() decorator then we check if we have any\n                        // type declarations in reflect-metadata (type declaration is emited only if some decorator is added to the property.)\n                        const reflectedType = Reflect.getMetadata(\"design:type\", (targetType as Function).prototype, propertyName);\n\n                        if (reflectedType) {\n                            type = reflectedType;\n                        }\n                    }\n                }\n\n                // if value is an array try to get its custom array type\n                const arrayType = Array.isArray(value[valueKey]) ? this.getReflectedType((targetType as Function), propertyName) : undefined;\n\n                // const subValueKey = TransformationType === TransformationType.PLAIN_TO_CLASS && newKeyName ? newKeyName : key;\n                const subSource = source ? source[valueKey] : undefined;\n\n                // if its deserialization then type if required\n                // if we uncomment this types like string[] will not work\n                // if (this.transformationType === TransformationType.PLAIN_TO_CLASS && !type && subValue instanceof Object && !(subValue instanceof Date))\n                //     throw new Error(`Cannot determine type for ${(targetType as any).name }.${propertyName}, did you forget to specify a @Type?`);\n\n                // if newValue is a source object that has method that match newKeyName then skip it\n                if (newValue.constructor.prototype) {\n                    const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);\n                    if ((this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)\n                        && ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function)) //  || TransformationType === TransformationType.CLASS_TO_CLASS\n                        continue;\n                }\n\n                if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {\n                    let transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;\n                    let finalValue;\n\n                    if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {\n                        // Get original value\n                        finalValue = value[transformKey];\n                        // Apply custom transformation\n                        finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), transformKey, value, this.transformationType);\n                        // If nothing change, it means no custom transformation was applied, so use the subValue.\n                        finalValue = (value[transformKey] === finalValue) ? subValue : finalValue;\n                        // Apply the default transformation\n                        finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);\n                    } else {\n                        finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);\n                        finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), transformKey, value, this.transformationType);\n                    }\n\n                    if (newValue instanceof Map) {\n                        newValue.set(newValueKey, finalValue);\n                    } else {\n                        newValue[newValueKey] = finalValue;\n                    }\n                } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {\n                    let finalValue = subValue;\n                    finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), key, value, this.transformationType);\n                    if (newValue instanceof Map) {\n                        newValue.set(newValueKey, finalValue);\n                    } else {\n                        newValue[newValueKey] = finalValue;\n                    }\n                }\n\n            }\n\n            if (this.options.enableCircularCheck) {\n                this.recursionStack.delete(value);\n            }\n\n            return newValue;\n\n        } else {\n            return value;\n        }\n    }\n\n    private applyCustomTransformations(value: any, target: Function, key: string, obj: any, transformationType: TransformationType) {\n        let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);\n\n        // apply versioning options\n        if (this.options.version !== undefined) {\n            metadatas = metadatas.filter(metadata => {\n                if (!metadata.options)\n                    return true;\n\n                return this.checkVersion(metadata.options.since, metadata.options.until);\n            });\n        }\n\n        // apply grouping options\n        if (this.options.groups && this.options.groups.length) {\n            metadatas = metadatas.filter(metadata => {\n                if (!metadata.options)\n                    return true;\n\n                return this.checkGroups(metadata.options.groups);\n            });\n        } else {\n            metadatas = metadatas.filter(metadata => {\n                return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;\n            });\n        }\n\n        metadatas.forEach(metadata => {\n            value = metadata.transformFn(value, obj, transformationType);\n        });\n\n        return value;\n    }\n\n    // preventing circular references\n    private isCircular(object: Object) {\n        return this.recursionStack.has(object);\n    }\n\n    private getReflectedType(target: Function, propertyName: string) {\n        if (!target) return undefined;\n        const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);\n        return meta ? meta.reflectedType : undefined;\n    }\n\n    private getKeys(target: Function, object: Object): string[] {\n\n        // determine exclusion strategy\n        let strategy = defaultMetadataStorage.getStrategy(target);\n        if (strategy === \"none\")\n            strategy = this.options.strategy || \"exposeAll\"; // exposeAll is default strategy\n\n        // get all keys that need to expose\n        let keys: any[] = [];\n        if (strategy === \"exposeAll\") {\n            if (object instanceof Map) {\n                keys = Array.from(object.keys());\n            } else {\n                keys = Object.keys(object);\n            }\n        }\n\n        if (!this.options.ignoreDecorators && target) {\n\n            // add all exposed to list of keys\n            let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);\n            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {\n                exposedProperties = exposedProperties.map(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {\n                        return exposeMetadata.options.name;\n                    }\n\n                    return key;\n                });\n            }\n            if (this.options.excludeExtraneousValues) {\n                keys = exposedProperties;\n            } else {\n                keys = keys.concat(exposedProperties);\n            }\n\n            // exclude excluded properties\n            const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);\n            if (excludedProperties.length > 0) {\n                keys = keys.filter(key => {\n                    return excludedProperties.indexOf(key) === -1;\n                });\n            }\n\n            // apply versioning options\n            if (this.options.version !== undefined) {\n                keys = keys.filter(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (!exposeMetadata || !exposeMetadata.options)\n                        return true;\n\n                    return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);\n                });\n            }\n\n            // apply grouping options\n            if (this.options.groups && this.options.groups.length) {\n                keys = keys.filter(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    if (!exposeMetadata || !exposeMetadata.options)\n                        return true;\n\n                    return this.checkGroups(exposeMetadata.options.groups);\n                });\n            } else {\n                keys = keys.filter(key => {\n                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);\n                    return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;\n                });\n            }\n        }\n\n        // exclude prefixed properties\n        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {\n            keys = keys.filter(key => this.options.excludePrefixes.every(prefix => {\n                return key.substr(0, prefix.length) !== prefix;\n            }));\n        }\n\n        // make sure we have unique keys\n        keys = keys.filter((key, index, self) => {\n            return self.indexOf(key) === index;\n        });\n\n        return keys;\n    }\n\n    private checkVersion(since: number, until: number) {\n        let decision = true;\n        if (decision && since)\n            decision = this.options.version >= since;\n        if (decision && until)\n            decision = this.options.version < until;\n\n        return decision;\n    }\n\n    private checkGroups(groups: string[]) {\n        if (!groups)\n            return true;\n\n        return this.options.groups.some(optionGroup => groups.indexOf(optionGroup) !== -1);\n    }\n\n}\n\nfunction instantiateArrayType(arrayType: Function): Array<any> | Set<any> {\n    const array = new (arrayType as any)();\n    if (!(array instanceof Set) && !(\"push\" in array)) {\n        return [];\n    }\n    return array;\n}\n\nexport function testForBuffer(): boolean {\n    try {\n        Buffer\n        return true;\n    } catch { }\n    return false;\n}\n"],"sourceRoot":"."},"metadata":{},"sourceType":"script"}