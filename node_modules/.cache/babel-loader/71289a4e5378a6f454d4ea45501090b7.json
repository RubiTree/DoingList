{"ast":null,"code":"import Format from '../utils/Format';\nimport Utils from '../utils/Utils';\n\nclass TaskInfoFormat {\n  static getDoingStatusTips(task) {\n    if (task.isDoing()) {\n      return \"Doingüî¥\"; // ‚õëüèÉ‚Äç‚ôÄÔ∏èüß† üèÑ‚Äç‚ôÇÔ∏è üåü üî¥\n    } else {\n      return \"\";\n    }\n  }\n\n  static getConsumed(task) {\n    let time = Format.formatDuration2(task.getAllDuration());\n\n    if (Utils.isStringEmpty(time)) {\n      return \"\";\n    }\n\n    return `ËøõË°å${time}(${task.doingDurs.length}Ê¨°) `;\n  }\n\n  static getDeadline(task) {\n    const pendingStatus = TaskInfoFormat.getPendingStatus(task);\n\n    if (Utils.isStringEmpty(pendingStatus)) {\n      return TaskInfoFormat.getDeadlineStatus(task);\n    } else {\n      return pendingStatus;\n    }\n  }\n\n  static getDeadlineStatus(task) {\n    let deadline = task.getActualDeadline();\n\n    if (deadline <= 0) {\n      return \"\";\n    }\n\n    const leftTime = deadline - Utils.getTimestamp();\n\n    if (leftTime <= 1000) {\n      return `DeadÂ∑≤Ë∂ÖÊúü‚ùó `;\n    }\n\n    let time = Format.formatDuration2(leftTime);\n    return `DeadÂâ©‰Ωô${time} `;\n  } // todo ÂêàÂπ∂ÈáçÂ§çÂáΩÊï∞\n\n\n  static getPendingStatus(task) {\n    let deadline = task.pendingDeadline;\n\n    if (deadline <= 0) {\n      return \"\";\n    }\n\n    const leftTime = deadline - Utils.getTimestamp();\n\n    if (leftTime <= 1000) {\n      return `PendÂ∑≤Ë∂ÖÊúü‚ùó `;\n    }\n\n    let time = Format.formatDuration2(leftTime);\n    return `PendÂâ©‰Ωô${time} `;\n  }\n\n  static getConsumeExpected(task) {\n    if (task.getActualExpectConsume() <= 0) {\n      return \"\";\n    }\n\n    let left = task.getLeftExpectConsumeTime();\n\n    if (left <= 0) {\n      return `Â§öÁî®${Format.formatDuration2(-left)} `;\n    } else {\n      return `ËøòË¶Å${Format.formatDuration2(left)} `;\n    }\n  }\n\n  static getStartExpected(task) {\n    const currentTime = Utils.getTimestamp();\n\n    if (currentTime > task.expectStartTime) {\n      return \"\";\n    }\n\n    return `ËøòÊúâ${Format.formatDuration2(task.expectStartTime - currentTime)}ÂºÄÂßã`;\n  }\n\n}\n\nexport default TaskInfoFormat;","map":{"version":3,"sources":["/Users/bear/Develop/vscode/self/study/study1/React/DoingList/doinglist2/src/utils/TaskInfoFormat.ts"],"names":["Format","Utils","TaskInfoFormat","getDoingStatusTips","task","isDoing","getConsumed","time","formatDuration2","getAllDuration","isStringEmpty","doingDurs","length","getDeadline","pendingStatus","getPendingStatus","getDeadlineStatus","deadline","getActualDeadline","leftTime","getTimestamp","pendingDeadline","getConsumeExpected","getActualExpectConsume","left","getLeftExpectConsumeTime","getStartExpected","currentTime","expectStartTime"],"mappings":"AACA,OAAOA,MAAP,MAAmB,iBAAnB;AACA,OAAOC,KAAP,MAAkB,gBAAlB;;AAEA,MAAMC,cAAN,CAAqB;AAEjB,SAAcC,kBAAd,CAAiCC,IAAjC,EAAqD;AACjD,QAAIA,IAAI,CAACC,OAAL,EAAJ,EAAoB;AAChB,aAAO,SAAP,CADgB,CAEhB;AACH,KAHD,MAGO;AACH,aAAO,EAAP;AACH;AACJ;;AAED,SAAcC,WAAd,CAA0BF,IAA1B,EAA8C;AAC1C,QAAIG,IAAI,GAAGP,MAAM,CAACQ,eAAP,CAAuBJ,IAAI,CAACK,cAAL,EAAvB,CAAX;;AACA,QAAIR,KAAK,CAACS,aAAN,CAAoBH,IAApB,CAAJ,EAA+B;AAC3B,aAAO,EAAP;AACH;;AACD,WAAQ,KAAIA,IAAK,IAAGH,IAAI,CAACO,SAAL,CAAeC,MAAO,KAA1C;AACH;;AAED,SAAcC,WAAd,CAA0BT,IAA1B,EAA8C;AAC1C,UAAMU,aAAa,GAAGZ,cAAc,CAACa,gBAAf,CAAgCX,IAAhC,CAAtB;;AACA,QAAIH,KAAK,CAACS,aAAN,CAAoBI,aAApB,CAAJ,EAAwC;AACpC,aAAOZ,cAAc,CAACc,iBAAf,CAAiCZ,IAAjC,CAAP;AACH,KAFD,MAEO;AACH,aAAOU,aAAP;AACH;AACJ;;AAED,SAAeE,iBAAf,CAAiCZ,IAAjC,EAAqD;AACjD,QAAIa,QAAQ,GAAGb,IAAI,CAACc,iBAAL,EAAf;;AACA,QAAID,QAAQ,IAAI,CAAhB,EAAmB;AACf,aAAO,EAAP;AACH;;AACD,UAAME,QAAQ,GAAGF,QAAQ,GAAGhB,KAAK,CAACmB,YAAN,EAA5B;;AACA,QAAID,QAAQ,IAAI,IAAhB,EAAsB;AAClB,aAAQ,WAAR;AACH;;AACD,QAAIZ,IAAI,GAAGP,MAAM,CAACQ,eAAP,CAAuBW,QAAvB,CAAX;AACA,WAAQ,SAAQZ,IAAK,GAArB;AACH,GAvCgB,CAyCjB;;;AACA,SAAeQ,gBAAf,CAAgCX,IAAhC,EAAoD;AAChD,QAAIa,QAAQ,GAAGb,IAAI,CAACiB,eAApB;;AACA,QAAIJ,QAAQ,IAAI,CAAhB,EAAmB;AACf,aAAO,EAAP;AACH;;AACD,UAAME,QAAQ,GAAGF,QAAQ,GAAGhB,KAAK,CAACmB,YAAN,EAA5B;;AACA,QAAID,QAAQ,IAAI,IAAhB,EAAsB;AAClB,aAAQ,WAAR;AACH;;AACD,QAAIZ,IAAI,GAAGP,MAAM,CAACQ,eAAP,CAAuBW,QAAvB,CAAX;AACA,WAAQ,SAAQZ,IAAK,GAArB;AACH;;AAED,SAAce,kBAAd,CAAiClB,IAAjC,EAAqD;AACjD,QAAIA,IAAI,CAACmB,sBAAL,MAAiC,CAArC,EAAwC;AACpC,aAAO,EAAP;AACH;;AAED,QAAIC,IAAI,GAAGpB,IAAI,CAACqB,wBAAL,EAAX;;AACA,QAAID,IAAI,IAAI,CAAZ,EAAe;AACX,aAAQ,KAAIxB,MAAM,CAACQ,eAAP,CAAuB,CAACgB,IAAxB,CAA8B,GAA1C;AACH,KAFD,MAEO;AACH,aAAQ,KAAIxB,MAAM,CAACQ,eAAP,CAAuBgB,IAAvB,CAA6B,GAAzC;AACH;AACJ;;AAED,SAAcE,gBAAd,CAA+BtB,IAA/B,EAAmD;AAC/C,UAAMuB,WAAW,GAAG1B,KAAK,CAACmB,YAAN,EAApB;;AACA,QAAGO,WAAW,GAAGvB,IAAI,CAACwB,eAAtB,EAAuC;AACnC,aAAO,EAAP;AACH;;AAED,WAAQ,KAAI5B,MAAM,CAACQ,eAAP,CAAuBJ,IAAI,CAACwB,eAAL,GAAuBD,WAA9C,CAA2D,IAAvE;AACH;;AA3EgB;;AA8ErB,eAAezB,cAAf","sourcesContent":["import { Task } from '../model/model'\nimport Format from '../utils/Format'\nimport Utils from '../utils/Utils'\n\nclass TaskInfoFormat {\n\n    public static getDoingStatusTips(task: Task): string {\n        if (task.isDoing()) {\n            return \"Doingüî¥\"\n            // ‚õëüèÉ‚Äç‚ôÄÔ∏èüß† üèÑ‚Äç‚ôÇÔ∏è üåü üî¥\n        } else {\n            return \"\"\n        }\n    }\n\n    public static getConsumed(task: Task): string {\n        let time = Format.formatDuration2(task.getAllDuration());\n        if (Utils.isStringEmpty(time)) {\n            return \"\"\n        }\n        return `ËøõË°å${time}(${task.doingDurs.length}Ê¨°) `\n    }\n\n    public static getDeadline(task: Task): string {\n        const pendingStatus = TaskInfoFormat.getPendingStatus(task)\n        if (Utils.isStringEmpty(pendingStatus)) {\n            return TaskInfoFormat.getDeadlineStatus(task)\n        } else {\n            return pendingStatus\n        }\n    }\n\n    private static getDeadlineStatus(task: Task): string {\n        let deadline = task.getActualDeadline()\n        if (deadline <= 0) {\n            return \"\"\n        }\n        const leftTime = deadline - Utils.getTimestamp();\n        if (leftTime <= 1000) {\n            return `DeadÂ∑≤Ë∂ÖÊúü‚ùó `\n        }\n        let time = Format.formatDuration2(leftTime);\n        return `DeadÂâ©‰Ωô${time} `\n    }\n\n    // todo ÂêàÂπ∂ÈáçÂ§çÂáΩÊï∞\n    private static getPendingStatus(task: Task): string {\n        let deadline = task.pendingDeadline\n        if (deadline <= 0) {\n            return \"\"\n        }\n        const leftTime = deadline - Utils.getTimestamp();\n        if (leftTime <= 1000) {\n            return `PendÂ∑≤Ë∂ÖÊúü‚ùó `\n        }\n        let time = Format.formatDuration2(leftTime);\n        return `PendÂâ©‰Ωô${time} `\n    }\n\n    public static getConsumeExpected(task: Task): string {\n        if (task.getActualExpectConsume() <= 0) {\n            return \"\"\n        }\n\n        let left = task.getLeftExpectConsumeTime()\n        if (left <= 0) {\n            return `Â§öÁî®${Format.formatDuration2(-left)} `\n        } else {\n            return `ËøòË¶Å${Format.formatDuration2(left)} `\n        }\n    }\n\n    public static getStartExpected(task: Task): string {\n        const currentTime = Utils.getTimestamp()\n        if(currentTime > task.expectStartTime) {\n            return \"\"\n        }\n\n        return `ËøòÊúâ${Format.formatDuration2(task.expectStartTime - currentTime)}ÂºÄÂßã`\n    }\n}\n\nexport default TaskInfoFormat"]},"metadata":{},"sourceType":"module"}