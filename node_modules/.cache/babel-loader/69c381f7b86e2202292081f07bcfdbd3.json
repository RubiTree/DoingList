{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ClassTransformer_1 = require(\"./ClassTransformer\");\n\nvar storage_1 = require(\"./storage\");\n\nvar TypeMetadata_1 = require(\"./metadata/TypeMetadata\");\n\nvar ExposeMetadata_1 = require(\"./metadata/ExposeMetadata\");\n\nvar ExcludeMetadata_1 = require(\"./metadata/ExcludeMetadata\");\n\nvar TransformMetadata_1 = require(\"./metadata/TransformMetadata\");\n/**\n * Defines a custom logic for value transformation.\n */\n\n\nfunction Transform(transformFn, options) {\n  return function (target, key) {\n    var metadata = new TransformMetadata_1.TransformMetadata(target.constructor, key, transformFn, options);\n    storage_1.defaultMetadataStorage.addTransformMetadata(metadata);\n  };\n}\n\nexports.Transform = Transform;\n/**\n * Specifies a type of the property.\n * The given TypeFunction can return a constructor. A discriminator can be given in the options.\n */\n\nfunction Type(typeFunction, options) {\n  return function (target, key) {\n    var type = Reflect.getMetadata(\"design:type\", target, key);\n    var metadata = new TypeMetadata_1.TypeMetadata(target.constructor, key, type, typeFunction, options);\n    storage_1.defaultMetadataStorage.addTypeMetadata(metadata);\n  };\n}\n\nexports.Type = Type;\n/**\n * Marks property as included in the process of transformation. By default it includes the property for both\n * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types\n * you want to skip this property.\n */\n\nfunction Expose(options) {\n  return function (object, propertyName) {\n    var metadata = new ExposeMetadata_1.ExposeMetadata(object instanceof Function ? object : object.constructor, propertyName, options || {});\n    storage_1.defaultMetadataStorage.addExposeMetadata(metadata);\n  };\n}\n\nexports.Expose = Expose;\n/**\n * Marks property as excluded from the process of transformation. By default it excludes the property for both\n * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types\n * you want to skip this property.\n */\n\nfunction Exclude(options) {\n  return function (object, propertyName) {\n    var metadata = new ExcludeMetadata_1.ExcludeMetadata(object instanceof Function ? object : object.constructor, propertyName, options || {});\n    storage_1.defaultMetadataStorage.addExcludeMetadata(metadata);\n  };\n}\n\nexports.Exclude = Exclude;\n/**\n * Transform the object from class to plain object and return only with the exposed properties.\n */\n\nfunction TransformClassToPlain(params) {\n  return function (target, propertyKey, descriptor) {\n    var classTransformer = new ClassTransformer_1.ClassTransformer();\n    var originalMethod = descriptor.value;\n\n    descriptor.value = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var result = originalMethod.apply(this, args);\n      var isPromise = !!result && (typeof result === \"object\" || typeof result === \"function\") && typeof result.then === \"function\";\n      return isPromise ? result.then(function (data) {\n        return classTransformer.classToPlain(data, params);\n      }) : classTransformer.classToPlain(result, params);\n    };\n  };\n}\n\nexports.TransformClassToPlain = TransformClassToPlain;\n/**\n * Return the class instance only with the exposed properties.\n */\n\nfunction TransformClassToClass(params) {\n  return function (target, propertyKey, descriptor) {\n    var classTransformer = new ClassTransformer_1.ClassTransformer();\n    var originalMethod = descriptor.value;\n\n    descriptor.value = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var result = originalMethod.apply(this, args);\n      var isPromise = !!result && (typeof result === \"object\" || typeof result === \"function\") && typeof result.then === \"function\";\n      return isPromise ? result.then(function (data) {\n        return classTransformer.classToClass(data, params);\n      }) : classTransformer.classToClass(result, params);\n    };\n  };\n}\n\nexports.TransformClassToClass = TransformClassToClass;\n/**\n * Return the class instance only with the exposed properties.\n */\n\nfunction TransformPlainToClass(classType, params) {\n  return function (target, propertyKey, descriptor) {\n    var classTransformer = new ClassTransformer_1.ClassTransformer();\n    var originalMethod = descriptor.value;\n\n    descriptor.value = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var result = originalMethod.apply(this, args);\n      var isPromise = !!result && (typeof result === \"object\" || typeof result === \"function\") && typeof result.then === \"function\";\n      return isPromise ? result.then(function (data) {\n        return classTransformer.plainToClass(classType, data, params);\n      }) : classTransformer.plainToClass(classType, result, params);\n    };\n  };\n}\n\nexports.TransformPlainToClass = TransformPlainToClass;","map":{"version":3,"sources":["../../src/decorators.ts"],"names":[],"mappings":"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","sourcesContent":["import {ClassTransformer} from \"./ClassTransformer\";\nimport {defaultMetadataStorage} from \"./storage\";\nimport {TypeMetadata} from \"./metadata/TypeMetadata\";\nimport {ExposeMetadata} from \"./metadata/ExposeMetadata\";\nimport {ExposeOptions, ExcludeOptions, TypeHelpOptions, TransformOptions, Discriminator, TypeOptions} from \"./metadata/ExposeExcludeOptions\";\nimport {ExcludeMetadata} from \"./metadata/ExcludeMetadata\";\nimport {TransformMetadata} from \"./metadata/TransformMetadata\";\nimport {ClassTransformOptions} from \"./ClassTransformOptions\";\nimport {TransformationType} from \"./TransformOperationExecutor\";\n\n/**\n * Defines a custom logic for value transformation.\n */\nexport function Transform(transformFn: (value: any, obj: any, transformationType: TransformationType) => any, options?: TransformOptions) {\n    return function(target: any, key: string) {\n        const metadata = new TransformMetadata(target.constructor, key, transformFn, options);\n        defaultMetadataStorage.addTransformMetadata(metadata);\n    };\n}\n\n/**\n * Specifies a type of the property.\n * The given TypeFunction can return a constructor. A discriminator can be given in the options.\n */\nexport function Type(typeFunction?: (type?: TypeHelpOptions) => Function, options?: TypeOptions) {\n    return function(target: any, key: string) {\n        const type = (Reflect as any).getMetadata(\"design:type\", target, key);\n        const metadata = new TypeMetadata(target.constructor, key, type, typeFunction, options);\n        defaultMetadataStorage.addTypeMetadata(metadata);\n    };\n}\n\n/**\n * Marks property as included in the process of transformation. By default it includes the property for both\n * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types\n * you want to skip this property.\n */\nexport function Expose(options?: ExposeOptions) {\n    return function(object: Object|Function, propertyName?: string) {\n        const metadata = new ExposeMetadata(object instanceof Function ? object : object.constructor, propertyName, options || {});\n        defaultMetadataStorage.addExposeMetadata(metadata);\n    };\n}\n\n/**\n * Marks property as excluded from the process of transformation. By default it excludes the property for both\n * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types\n * you want to skip this property.\n */\nexport function Exclude(options?: ExcludeOptions) {\n    return function(object: Object|Function, propertyName?: string) {\n        const metadata = new ExcludeMetadata(object instanceof Function ? object : object.constructor, propertyName, options || {});\n        defaultMetadataStorage.addExcludeMetadata(metadata);\n    };\n}\n\n/**\n * Transform the object from class to plain object and return only with the exposed properties.\n */\nexport function TransformClassToPlain(params?: ClassTransformOptions): Function {\n\n    return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor) {\n        const classTransformer: ClassTransformer = new ClassTransformer();\n        const originalMethod = descriptor.value;\n\n        descriptor.value = function(...args: any[]) {\n            const result: any = originalMethod.apply(this, args);\n            const isPromise = !!result && (typeof result === \"object\" || typeof result === \"function\") && typeof result.then === \"function\";\n\n            return isPromise ? result.then((data: any) => classTransformer.classToPlain(data, params)) : classTransformer.classToPlain(result, params);\n        };\n    };\n}\n\n/**\n * Return the class instance only with the exposed properties.\n */\nexport function TransformClassToClass(params?: ClassTransformOptions): Function {\n\n    return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor) {\n        const classTransformer: ClassTransformer = new ClassTransformer();\n        const originalMethod = descriptor.value;\n\n        descriptor.value = function(...args: any[]) {\n            const result: any = originalMethod.apply(this, args);\n            const isPromise = !!result && (typeof result === \"object\" || typeof result === \"function\") && typeof result.then === \"function\";\n\n            return isPromise ? result.then((data: any) => classTransformer.classToClass(data, params)) : classTransformer.classToClass(result, params);\n        };\n    };\n}\n\n/**\n * Return the class instance only with the exposed properties.\n */\nexport function TransformPlainToClass(classType: any, params?: ClassTransformOptions): Function {\n\n    return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor) {\n        const classTransformer: ClassTransformer = new ClassTransformer();\n        const originalMethod = descriptor.value;\n\n        descriptor.value = function(...args: any[]) {\n            const result: any = originalMethod.apply(this, args);\n            const isPromise = !!result && (typeof result === \"object\" || typeof result === \"function\") && typeof result.then === \"function\";\n\n            return isPromise ? result.then((data: any) => classTransformer.plainToClass(classType, data, params)) : classTransformer.plainToClass(classType, result, params);\n        };\n    };\n}\n"],"sourceRoot":"."},"metadata":{},"sourceType":"script"}